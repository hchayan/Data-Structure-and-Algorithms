# 13. íŠ¸ë¦¬

: íŠ¸ë¦¬(tree) í˜•íƒœì˜ ìë£Œêµ¬ì¡°

: **ì¬ê·€ë¡œ ì •ì˜ëœ ìê¸° ì°¸ì¡° ìë£Œêµ¬ì¡°**

<br>

#### [íŠ¸ë¦¬ì˜ ëª…ì¹­]

----

![image-20201005134314812](C:\Users\Chayan\AppData\Roaming\Typora\typora-user-images\image-20201005134314812.png)

<br>

#### [ê·¸ë˜í”„ì™€ íŠ¸ë¦¬ì˜ ì°¨ì´]

-----

: **íŠ¸ë¦¬ëŠ” ìˆœí™˜ êµ¬ì¡°ë¥¼ ê°–ì§€ ì•ŠëŠ” ê·¸ë˜í”„**

<br>

#### [ì´ì§„íŠ¸ë¦¬]

----

: ê°€ì¥ ê¸°ë³¸ì ì¸ íŠ¸ë¦¬ì˜ í˜•íƒœ

: **ëª¨ë“  ë…¸ë“œì˜ ì°¨ìˆ˜ê°€ 2 ì´í•˜ì¸ íŠ¸ë¦¬**

- ì •ì´ì§„ íŠ¸ë¦¬ : ëª¨ë“  ë…¸ë“œê°€ 0ê°œ ë˜ëŠ” 2ê°œì˜ ìì‹ ë…¸ë“œë¥¼ ê°–ëŠ”ë‹¤
- ì™„ì „ ì´ì§„ íŠ¸ë¦¬ : ë§ˆì§€ë§‰ ë ˆë²¨ ì œì™¸ ëª¨ë“  ë ˆë²¨ì´ ì™„ì „ ì±„ì›Œì ¸ ìˆìœ¼ë©°, ë§ˆì§€ë§‰ ë ˆë²¨ì˜ ëª¨ë“  ë…¸ë“œëŠ” ê°€ì¥ ì™¼ìª½ë¶€í„° ì±„ì›Œì§
- í¬í™” ì´ì§„ íŠ¸ë¦¬ : ëª¨ë“  ë…¸ë“œê°€ 2ê°œì˜ ìì‹ ë…¸ë“œ ê°–ê³  ìˆìœ¼ë©°, ëª¨ë“  ë¦¬í”„ ë…¸ë“œê°€ ë™ì¼í•œ ê¹Šì´ ë˜ëŠ” ë ˆë²¨ ê°€ì§.

<br>

#### [íŠ¸ë¦¬ ë¬¸ì œ]

----

1. **íŠ¸ë¦¬ì˜ ìµœëŒ€ ê¹Šì´ êµ¬í•˜ê¸° - leetcode 104**

   ```
   ì£¼ì–´ì§„ íŠ¸ë¦¬ ë…¸ë“œ êµ¬ì¡°.
   # def __init__(self, val=0, left=None, right=None):
   #         self.val = val
   #         self.left = left
   #         self.right = right
   ```

   ```python
   class Solution:
       def maxDepth(self, root: TreeNode) -> int:
           if root is None:
               return 0
           
           tree = collections.deque([root])
           depth = 0
           
           # BFS ì‚¬ìš©
           while tree:
               depth += 1
               for _ in range(len(tree)):
                   cur_root = tree.popleft()
                   if cur_root.left:
                       tree.append(cur_root.left)
                   if cur_root.right:
                       tree.append(cur_root.right)
           return depth
           
   ```

   <br>

2. **ì´ì§„ íŠ¸ë¦¬ì˜ ì§ê²½ - leetcode 543 ğŸ˜¡ğŸ˜¡**

   ```
   ì´ì§„ íŠ¸ë¦¬ì—ì„œ ë‘ ë…¸ë“œê°„ ê°€ì¥ ê¸´ ê²½ë¡œì˜ ê¸¸ì´ë¥¼ ì¶œë ¥í•´ë¼.
   
   	1
     2   3
   4  5
   
   ê°€ì¥ ê¸´ ê²½ë¡œëŠ” 4-2-1-3 or 5-2-1-3ìœ¼ë¡œ 3ì´ë‹¤.
   ```

   ```
   # rootì—ì„œ left, right ë³„ë¡œ ê°€ì¥ ê¸´ ê¸¸ì´ë¥¼ êµ¬í•´ ë”í•˜ëŠ” ë°©ì‹ì˜ í’€ì´.
   ```

   ```python
   # ì¬ê·€ ë°©ì‹ìœ¼ë¡œ ê° ë…¸ë“œë³„ ìµœëŒ€ ê²½ë¡œ ê¸¸ì´ íƒìƒ‰.
   class Solution:
       
       longest = 0
       def diameterOfBinaryTree(self, root: TreeNode) -> int:
           def dfs(node):
               if not node:
                   return -1
               
               left = dfs(node.left)
               right = dfs(node.right)
               
               # ê°€ì¥ ê¸´ ê²½ë¡œ
               self.longest = max(self.longest, left + right + 2) ğŸ˜¡
               return max(left, right) + 1
           
           dfs(root)
           return self.longest
           
   ```

   <br>
   
3. **ê°€ì¥ ê¸´ ë™ì¼ ê°’ì˜ ê²½ë¡œ - leetcode 687 ğŸ˜¡ğŸ˜¡**

   ```
   ë™ì¼í•œ ê°’ ì„ ì§€ë‹Œ ê°€ì¥ ê¸´ ê²½ë¡œë¥¼ ì°¾ì•„ë¼
   
       5
     4   5
   1  1    5
   
   2 (5->5->5)
   ```

   ```js
   class Solution:
       result = 0
       
       def longestUnivaluePath(self, root: TreeNode) -> int:
           def dfs(node):
               if node is None:
                   return 0
               
               left = dfs(node.left)
               right = dfs(node.right)
           
               if node.left and node.left.val == node.val:
                   left += 1
               else:
                   left = 0
                   
               if node.right and node.right.val == node.val:
                   right += 1
               else:
                   right = 0
                   
               self.result = max(self.result, left + right)
               return max(left, right)
           
           dfs(root)
           return self.result
   ```

   : **2ë²ˆê³¼ ìœ ì‚¬í•œ í’€ì´**

   : **í•˜ë‚˜ì”© ë‚´ë ¤ê°€ë©° root ì¡ê³ , ê·¸ ìƒíƒœì—ì„œ left, rightë¥¼ ì¬ê·€ë°©ì‹ íƒìƒ‰í•˜ë©°, ë™ì¼ê°’ì„ ì°¾ì•„ ë”í•¨.**

   : ì´ ë”í•œ ê°’ì„ resultì™€ ë¹„êµí•´ ë” í°ê°’ ì €ì¥.

   ```
       5
     4   2
   4  4    1
   
   ì´ë©´ 4->4->4 ë¡œ 2
   ```

   <br>

4. **ì´ì§„ íŠ¸ë¦¬ ë°˜ì „ - leetcode 226**

   ```
       4
     2   7
   1  3 6  9
   =>
       4
     7   2
   9  6 3  1
   ```

   ```python
   # í’€ì´1. í•´ë‹¹ rootì˜ leftì™€ rightë¥¼ rightì™€ leftë¡œ ë°”ê¾¸ë©´ì„œ, 
   # ê·¸ ì•„ë˜ë¥¼ ì¬ê·€ ë°©ì‹ìœ¼ë¡œ ìœ„ ì‘ì—… ìˆ˜í–‰í•´ì£¼ëŠ” ë°©ì‹
   class Solution:
       def invertTree(self, root: TreeNode) -> TreeNode:
           if root:
               root.left, root.right = self.invertTree(root.right), self.invertTree(root.left);
               return root
   ```

   ```python
   # í’€ì´ 2. BFS ë°©ì‹ìœ¼ë¡œ ìœ„ì—ì„œë¶€í„° left.right êµí˜¸ë‚˜ ë°©ì‹
   class Solution:
       def invertTree(self, root: TreeNode) -> TreeNode:
           queue = collections.deque([root])
           
           while queue:
               node = queue.popleft()
               # ë¶€ëª¨ ë…¸ë“œë¶€í„° í•˜í–¥ì‹ ìŠ¤ì™‘ - BFS
               if node:
                   # ë§êµí™˜í›„ queueì— ì‚½ì…(= ì›ë˜ì™€ ë°˜ëŒ€ ìˆœì„œëŒ€ë¡œ ë¶€ëª¨ë¶€í„° êº¼ëƒ„)
                   node.left, node.right = node.right, node.left
                 
                   queue.append(node.left) 
                   queue.append(node.right)
                   # print(node.val, queue)
           return root
       
   '''
   4, [(7, 6, 9), (2, 1, 3)]
   7, [(2, 1, 3), (9, n, n), (6, n, n)]
   2, ...
   '''
   ```

   <br>
   
5. **ë‘ ì´ì§„ íŠ¸ë¦¬ ë³‘í•© - leetcode 617**

   ```
   ì£¼ì–´ì§„ ë‘ ì´ì§„ íŠ¸ë¦¬ì˜ ê°’ì„ ë”í•´ë¼
   
   Input: 
   	Tree 1                     Tree 2                  
             1                         2                             
            / \                       / \                            
           3   2                     1   3                        
          /                           \   \                      
         5                             4   7                  
   Output: 
   Merged tree:
   	     3
   	    / \
   	   4   5
   	  / \   \ 
   	 5   4   7
   ```

   ```js
   class Solution:
       def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
           if t1 and t2:
               node = TreeNode(t1.val + t2.val)
               node.left = self.mergeTrees(t1.left, t2.right)
               node.right = self.mergeTrees(t1.right, t2.right)
               
               return node
           else:
               return t1 or t2
   ```

   <br>

6. **ê· í˜• ì´ì§„ íŠ¸ë¦¬ (AVL íŠ¸ë¦¬) - leetcode 110**

   ```js
   ì´ì§„íŠ¸ë¦¬ê°€ ë†’ì´ ê· í˜•(AVLíŠ¸ë¦¬)ì¸ì§€ íŒë‹¨í•´ë¼.
   
   ì™¼ìª½, ì˜¤ë¥´ë¥¸ìª½ ë†’ì´ ì°¨ì´ 1 ì´ìƒì´ë©´ ê· í˜• X.
   ```

   ```js
   class Solution:
       def isBalanced(self, root: TreeNode) -> bool:
           def check(root):
               if root is None:
                   return 0
   
               left = check(root.left)
               right = check(root.right)
               
               # AVL íŠ¸ë¦¬ ê²€ì¦ (ë†’ì´ ì°¨ì´ ë‚˜ë©´ -1, ì´ì™¸ì—ëŠ” ë†’ì´ì— ë”°ë¼ 1 ì¦ê°€)
               if left == -1 or right == -1 or abs(left-right) > 1:
                   return -1
               
               return max(left, right) + 1
           
           return check(root) != -1
   ```

   

