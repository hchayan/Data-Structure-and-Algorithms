# 10(2). ê·¸ë˜í”„ ë¬¸ì œ

#### [1. leetcode 200 - ì„¬ì˜ ê°œìˆ˜] ğŸ˜¡

----

: **ì¬ê·€ ë°©ì‹ì˜ DFS ì‚¬ìš©í•œ ê·¸ë˜í”„ íƒìƒ‰**

```
1ì„ ìœ¡ì§€ë¡œ 0ì„ ë¬¼ë¡œ ê°€ì •í•œ 2D ê·¸ë¦¬ë“œ ë§µì´ ì£¼ì–´ì¡Œì„ë•Œ ì„¬ì˜ ê°œìˆ˜ë¥¼ ê³„ì‚°í•˜ë¼.

11110
11010
11000
00000

1
```

```python
# ì¬ê·€ ë°©ì‹ì˜ dfsë¡œ ê·¸ë˜í”„ íƒìƒ‰.
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(i, j):
            # ë•…ì´ ì•„ë‹Œê²½ìš° ì¬ê·€ ì¢…ë£Œ - 
            # ì¤‘ì²©í•¨ìˆ˜(í•¨ìˆ˜ì•ˆì— í•¨ìˆ˜)ì¨ì„œ global, self ì‚¬ìš©ì—†ì´ ë°”ë¡œ grid ì‚¬ìš© ê°€ëŠ¥
            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) 
            or grid[i][j] != '1':
                return
            
            # ì¤‘ì²©íƒìƒ‰ ë°©ì§€ìœ„í•´ ì§€ì›€
            grid[i][j] = 0
            
            dfs(i+1, j)
            dfs(i-1, j)
            dfs(i, j+1)
            dfs(i, j-1)
            
    
        cnt = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    dfs(i,j)
                    # ëª¨ë“  ìœ¡ì§€ íƒìƒ‰í›„ cnt 1 ì¦ê°€
                    cnt += 1
                
        return cnt
        
```

<br>

#### [2. leetcode 17. ì „í™”ë²ˆí˜¸ ë¬¸ì ì¡°í•©]

----

: **ì¡°í•© ë¬¸ì œ**

```
2ì—ì„œ 9ê¹Œì§€ ìˆ«ìê°€ ì£¼ì–´ì¡Œì„ë•Œ ì „í™” ë²ˆí˜¸ë¡œ ì¡°í•© ê°€ëŠ¥í•œ ëª¨ë“  ë¬¸ìë¥¼ ì¶œë ¥í•˜ë¼.
"23"

["ad", "ae", "af", ...]
```

```python
from itertools import product

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if len(digits) == 0:
            return []
        
        words = {'2':'abc', '3' : 'def', '4' : 'ghi', '5' : 'jkl', '6' : 'mno', '7' : 'pqrs', '8' : 'tuv', '9' : 'wxyz'}
        lis = []
        for s in digits:
            lis.append(list(words[s]))
        
        ans = [] 
        for l in list(product(*lis)): ğŸ˜¡
            ans.append("".join(l))
        
        return ans
```

<br>

#### [3. leetcode 34 - ìˆœì—´]

-----

: ì„œë¡œ ë‹¤ë¥¸ ì •ìˆ˜ ì…ë ¥ë°›ì•„ ê°€ëŠ¥í•œ ëª¨ë“  ìˆœì—´ ë¦¬í„´

```
[1,2,3]

[
	[1,2,3],
	[1,3,2],
	[2,1,3],
	[2,3,1],
	[3,1,2],
	[3,2,1]
]
```

```
# 1. itertool ì•„ë‹Œ DFS í™œìš©í•œ ìˆœì—´ ìƒì„±
# ëª¨ë“  ê°€ëŠ¥í•œ ê²½ìš°ë¥¼ ê·¸ë˜í”„ í˜•íƒœë¡œ ë‚˜ì—´í•œ ê²°ê³¼..
```

```python
# 2. itertool
def permute(self, nums):
	return(list(itertools.permutations(nums)))
```

<br>

#### [4. leetcode 35 - ì¡°í•©]

----

```
n = 4, k = 2    # ì „ì²´ ìˆ˜ nì„ ì…ë ¥ë°›ì•„ kê°œì˜ ì¡°í•© ë¦¬í„´
```

```
[
	[2,4],
	[3,4],
	[2,3],
	[1,2],
	[1,3],
	[1,4]
]
```

```python
def combine(self, n, k):
	return(list(itertools.combinations(range(1, n+1), k)))
```

: **dfsë¡œ êµ¬í˜„í•˜ë©´ kê°’ ë³„ë„ë¡œ ì „ë‹¬ë°›ì•„ 1ì”© ì¤„ì—¬ë‚˜ê°€ë©° ì¬ê·€ í˜¸ì¶œí•˜ëŠ” êµ¬ì¡°, 0 ë˜ë©´ ì¢…ë£Œ**

<br>

#### [5. leetcode 39 - ì¡°í•©ì˜ í•©] ğŸ˜¡ğŸ˜¡ë°±íŠ¸ë˜í‚¹+DFS ê¸°ë³¸

---

: **ì¬ê·€ íƒìƒ‰ ê¸°ë³¸**

```
ìˆ«ì¡ ì§‘í•© ì¡°í•©í•´ í•©ì´ trget ë˜ëŠ” ì›ì†Œ ë‚˜ì—´

candidates = [2,3,6,7], target = 7

[
	[7],
	[2,2,3],
]
```

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        # DFSì™€ ë°±íŠ¸ë˜í‚¹ì˜ ì¡°í•©
        res = []
        def dfs(csum, index, path):
            if csum < 0:
                return
            if csum == 0:
                res.append(path)
                return
            
            for i in range(index, len(candidates)):
                dfs(csum - candidates[i], i, path + [candidates[i]])
                
        dfs(target, 0, [])
        return res
```

<br>

#### [6. leetcode78 - ë¶€ë¶„ ì§‘í•©] ğŸ˜¡ğŸ˜¡

----

: **ì¬ê·€ íƒìƒ‰ ê¸°ë³¸**

````
nums = [1,2,3]

[
	[3],
	[1],
	[2],
	[1,2,3],
	...
]
````

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        
        def dfs(index, path):
            res.append(path)
            
            for i in range(index, len(nums)): ğŸ˜¡
                dfs(i + 1, path + [nums[i]])  ğŸ˜¡
                
        dfs(0, [])
        return res
```

<br>

#### [7.leetcode 332 - ì¼ì • ì¬êµ¬ì„±]

---

```
Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]

'JFK' ì‹œì‘. ì‚¬ì „ìˆœ. ë‹¤ íƒìƒ‰ ëª»í•˜ë©´.. ë‹¤ë¥¸ ê²½ë¡œ.
```

```python
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        
        graph = collections.defaultdict(list)
        
        for a, b in sorted(tickets):  # ì–´íœ˜ìˆœ ë°©ë¬¸í•„ìš”
            graph[a].append(b)
            
        print(graph)
        
        
        route = []
        def dfs(a): # ì¬ê·€ì‹ dfs
            while graph[a]:
                dfs(graph[a].pop(0))
            route.append(a)
            
        dfs('JFK')
        return route[::-1]
```

